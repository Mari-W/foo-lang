use std::conv;
use std::env;
use std::file;
use std::io;
use std::proc;
use std::time;


struct UnitStruct
struct TupleStruct(Int, Int)
struct RecordStruct {
    x: Int, 
    y: Int
}

enum Enum {
    UnitVariant,
    TupleVariant(Int, Int),
    RecordVariant { x: Int, y: Int },
    RecursiveVariant(Enum)
}

fn main() {
    ()
}

fn types() {
    let u: () = ()
    let i: Int = 42
    let b: Bool = true
    let s: Str = "Hello Mom!"
    let t: (Int, Int) = (42, 42)
    let r: { x: Int, y: Int } = { x: 42, y: 42 }
    let f: Int -> Int = |i: Int| i + 1

    let us: UnitStruct = UnitStruct
    let ts: TupleStruct = TupleStruct(42, 42)
    let rs: RecordStruct = RecordStruct { x: 42, y: 42 }

    let eu: Enum = Enum::UnitVariant
    let et: Enum = Enum::TupleVariant(42, 42)
    let er: Enum = Enum::RecordVariant { x: 42, y: 42 }
}

fn pattern_matching() {
    pattern_match_x(Enum::RecursiveVariant(Enum::RecordVariant{
        x: 42,
        y: -1
    }));
    patterns((42, 42));
    patterns((42, 41));
    patterns((-1, -1))
}

fn pattern_match_x(e: Enum) {
    match e {
        Enum::UnitVariant => io::println("Nothing"),
        Enum::TupleVariant(i, _) => io::println(conv::int_to_str(i)),
        Enum::RecordVariant{ x, y: _ } => io::println(conv::int_to_str(x)),
        Enum::RecursiveVariant(e) => pattern_match_x(e) 
    }
}

fn patterns((i, j): (Int, Int)) {
    match (i, j) {
        (42, 42) => io::println("Good choice!"),
        (42, x) | (x, 42) => io::println("Almost, but " + conv::int_to_str(x) + " seems off!"),
        _ => io::println("This seems wrong.")
    }
}


fn fib(n: Int) -> Int {
    match n {
        0 | 1 => n,
        _ => fib(n - 1) + fib(n - 2)
    }
}